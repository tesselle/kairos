---
title: "Seriation"
author: "N. Frerebeau"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: yes
    fig_caption: yes
    toc: true
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{Seriation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE, echo=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r packages}
# Load packages
library(kairos)
library(khroma) # Colour schemes
library(folio) # Datasets
library(dimensio) # Multivariate analysis
```

# Introduction

The matrix seriation problem in archaeology is based on three conditions and two assumptions, which @dunnell1970 summarizes as follows.

The homogeneity conditions state that all the groups included in a seriation must:

* Be of comparable duration,
* Belong to the same cultural tradition,
* Come from the same local area.

The mathematical assumptions state that the distribution of any historical or temporal class:

* Is continuous through time,
* Exhibits the form of a unimodal curve.

Theses assumptions create a distributional model and ordering is accomplished by arranging the matrix so that the class distributions approximate the required pattern. The resulting order is *inferred* to be chronological.

# Reciprocal ranking

Reciprocal ranking iteratively rearrange rows and/or columns according to their weighted rank in the data matrix until convergence [@ihm2005].

For a given incidence matrix $C$:

* The rows of $C$ are rearranged in increasing order of:

$$ x_{i} = \sum_{j = 1}^{p} j \frac{c_{ij}}{c_{i \cdot}} $$

* The columns of $C$ are rearranged in a similar way:

$$ y_{j} = \sum_{i = 1}^{m} i \frac{c_{ij}}{c_{\cdot j}} $$

These two steps are repeated until convergence.
Note that this procedure could enter into an infinite loop.

```{r reciprocal, fig.width=3.5, fig.height=3.5, fig.show='hold'}
## Build an incidence matrix with random data
set.seed(12345)
incidence1 <- matrix(sample(0:1, 400, TRUE, c(0.6, 0.4)), nrow = 20)

## Get seriation order on rows and columns
## If no convergence is reached before the maximum number of iterations (100), 
## it stops with a warning.
(indices <- seriate_rank(incidence1, margin = c(1, 2), stop = 100))

## Permute matrix rows and columns
incidence2 <- permute(incidence1, indices)

## Plot matrix
heatmap(incidence1, Rowv = NA, Colv = NA, revC = TRUE, 
        scale = "none", col = c("white", "black"))
heatmap(incidence2, Rowv = NA, Colv = NA, revC = TRUE, 
        scale = "none", col = c("white", "black"))
```

The positive difference from the column mean percentage (in french "Ã©cart positif au pourcentage moyen", EPPM) represents a deviation from the situation of statistical independence [@desachy2004]. As independence can be interpreted as the absence of relationships between types and the chronological order of the assemblages, EPPM is a useful graphical tool to explore significance of relationship between rows and columns related to seriation [@desachy2004].

```{r average, fig.width=7, fig.height=3.5}
## Replicates Desachy 2004 results
data("compiegne", package = "folio")

## Get seriation order for columns on EPPM using the reciprocal averaging method
## Expected column order: N, A, C, K, P, L, B, E, I, M, D, G, O, J, F, H
(indices <- seriate_rank(compiegne, EPPM = TRUE, margin = 2))

## Permute columns
compiegne_permuted <- permute(compiegne, indices)
```

# Correspondence analysis

Correspondence Analysis (CA) is an effective method for the seriation of archaeological assemblages. The order of the rows and columns is given by the coordinates along one dimension of the CA space, assumed to account for temporal variation. The direction of temporal change within the correspondence analysis space is arbitrary: additional information is needed to determine the actual order in time.

```{r ca}
data("zuni", package = "folio")

## correspondence analysis of the whole dataset
corresp <- dimensio::ca(zuni)

## Plot CA results
dimensio::plot(corresp) +
  ggplot2::theme_bw()
```

```{r ca-seriation, fig.width=7, fig.height=7}
## Get row permutations from CA coordinates
(indices <- seriate_average(zuni, margin = 1))

## Permute data matrix
zuni_permuted <- permute(zuni, indices)
```

# References
